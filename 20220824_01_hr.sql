--------------------------------------------------------------------------------
/*
--■■■ 무결성(Integrity) ■■■--

1. 무결성에는 개체 무결성(Entity Integrity)
              참조 무결성(Relation Integrity)
              도메인 무결성(Domain Integrity)이 있다.
              
-- 무결성이 유지되려면 제약조건이 있어야한다.
--자유롭게 입력하지못하도록 제약사항 명시, 오라클이 막는다.

2. 개체 무결성(Entity Integrity)
   개체 무결성은 릴레이션에서 저장되는 튜플(tuple)의
   유일성을 보장하기 위한 제약조건이다.
   
   
3. 참조 무결성(Relation Integrity)ㄴ
   참조 무결성은 릴레이션 간의 데이터 일관성을
   보장하기위한 제약조건이다.
    
4. 도메인 무결성(Domain Integrity)이 있다.
   도메인 무결성은 허용가능한 값의 범위를
   지정하기 위한 제약조건이다.

5. 제약조건의 종류

 - PRIMARY KEY(PK : P) → 기본키, 고유키, 식별키, 식별자
   해당 컬럼의 값은 반드시 존재해야 하며, 유일해야한다.
   (NOT NULL 과 UNIQUE 가 결합된 형태)

 - FOREIGN KEY(FK : F : R) → 외래키, 외부키, 참조키
   해당 컬럼의 값은 참조되는 테이블의 컬럼 데이터들 중 하나와
   일치하거나 NULL을 가진다.
   -- EMP테이블 의 DEPTNO   DEPT 테이블중DEPTNO 하나이거나 인턴(NULL)이거나  
 
 - UNIQUE(UK : U) 
   테이블 내에서 해당 컬럼의 값은 항상 유일해야 한다.

 - NOT NULL(NN : CK : C) 체크
   해당 컬럼은 NULL 을 포함할 수 없다.
   
 - CHECK(CK : C)
   해당 컬럼에 저장 가능한 데이터의 범위나 조건을 저장한다.

*/

--■■■ PRIMARY KEY ■■■--

--1. 테이블에 대한 기본 키를 생성한다.


                                        -- 싱글 ,  복합  
--2. 테이블에서 각 행을 유일하게 식별하는 컬럼 또는 컬럼의 집합이다.
--  기본키는 테이블 당 최대 하나만 존재한다.
--  그러나 반드시 하나의 컬럼으로만 구성되는 것은 아니다.
--  NULL일 수 없고, 이미 테이블에 존재하고 있는 데이터를
--  다시 입력할 수 없도록 처리한다. (유일성)
--  UNIQUE INDEX 가 오라클 내부적으로 자동으로 생성된다.

--3. 형식 및 구조
-- ① 컬럼 레벨의 형식
-- 컬럼명 데이터타입[CONSTRAINT CONSTRAINT명] PRIMARY KEY[(컬럼명,..)]

-- ② 테이블 레벨의 형식     ㅇ★★★★추천
-- 컬럼명 데이터 타입,
-- 컬럼명 데이터 타입,
-- CONSTRAINT CONSTRAINT명 PRIMARY KEY[(컬럼명,..)

-- 4. CONSTRAINT 추가 시 CONSTRAINT명을 생략하면
--    오라클 서버가 자동적으로 CONSTRAINT명을 부여한다.
--    일반적으로 CONSTRAINT명은 『테이블명_컬럼명_CONSTRAINT약자』
--    형식으로 기술한다.               


--○ PK지정 실습 (① 컬럼 레벨의 형식)
--테이블생성

CREATE TABLE TBL_TEST1
( COL1  NUMBER(5)       PRIMARY KEY
, COL2  VARCHAR2(30)
);
--==>> Table TBL_TEST1이(가) 생성되었습니다.
SELECT *
FROM TBL_TEST1;

DESC TBL_TEST1;
/*
이름   널?       유형           
---- -------- ------------ 
COL1 NOT NULL NUMBER(5)    
COL2          VARCHAR2(30) 

*/
-- 데이터 입력
INSERT INTO TBL_TEST1(COL1, COL2) VALUES(1,'TEST');  
INSERT INTO TBL_TEST1(COL1, COL2) VALUES(1,'TEST');  --> 에러발생
INSERT INTO TBL_TEST1(COL1, COL2) VALUES(1,'ABCD');  --> 에러발생
INSERT INTO TBL_TEST1(COL1, COL2) VALUES(2,'ABCD');  
INSERT INTO TBL_TEST1(COL1, COL2) VALUES(3,NULL);    
INSERT INTO TBL_TEST1(COL1) VALUES(4);              --> 행 삽입 완료, 502랑 같은 구문
INSERT INTO TBL_TEST1(COL1) VALUES(4);              --> 에러발생
INSERT INTO TBL_TEST1(COL1, COL2) VALUES(5,'ABCD');
INSERT INTO TBL_TEST1(COL1, COL2) VALUES(NULL,NULL); --> 에러발생


COMMIT;
--==>> 커밋 완료.

SELECT *
FROM TBL_TEST1;
/*
1	TEST
2	ABCD
3	(null)
4	(null)
5	ABCD
*/

DESC TBL_TEST1;
/*
이름   널?       유형           
---- -------- ------------ 
COL1 NOT NULL NUMBER(5)         → PK 제약조건 확인 불가    
COL2          VARCHAR2(30) 

*/


--※ 제약조건 확인
SELECT *
FROM USER_CONSTRAINTS;
/*
HR	SYS_C004102	O	EMP_DETAILS_VIEW					ENABLED	NOT DEFERRABLE
HR	JHIST_DATE_INTERVAL	C	JOB_HISTORY	end_date > start_date				ENABLED	NOT DEFERRABLE
HR	JHIST_JOB_NN	C	JOB_HISTORY	"JOB_ID" IS NOT NULL				ENABLED	NOT DEFERRABLE
HR	JHIST_END_DATE_NN	C	JOB_HISTORY	"END_DATE" IS NOT NULL				ENABLED	NOT DEFERRABLE
HR	JHIST_START_DATE_NN	C	JOB_HISTORY	"START_DATE" IS NOT NULL				ENABLED	NOT DEFERRABLE
HR	JHIST_EMPLOYEE_NN	C	JOB_HISTORY	"EMPLOYEE_ID" IS NOT NULL				ENABLED	NOT DEFERRABLE
HR	EMP_SALARY_MIN	C	EMPLOYEES	salary > 0				ENABLED	NOT DEFERRABLE
HR	EMP_JOB_NN	C	EMPLOYEES	"JOB_ID" IS NOT NULL				ENABLED	NOT DEFERRABLE
HR	EMP_HIRE_DATE_NN	C	EMPLOYEES	"HIRE_DATE" IS NOT NULL				ENABLED	NOT DEFERRABLE
HR	EMP_EMAIL_NN	C	EMPLOYEES	"EMAIL" IS NOT NULL				ENABLED	NOT DEFERRABLE
HR	EMP_LAST_NAME_NN	C	EMPLOYEES	"LAST_NAME" IS NOT NULL				ENABLED	NOT DEFERRABLE
HR	JOB_TITLE_NN	C	JOBS	"JOB_TITLE" IS NOT NULL				ENABLED	NOT DEFERRABLE
HR	DEPT_NAME_NN	C	DEPARTMENTS	"DEPARTMENT_NAME" IS NOT NULL				ENABLED	NOT DEFERRABLE
HR	LOC_CITY_NN	C	LOCATIONS	"CITY" IS NOT NULL				ENABLED	NOT DEFERRABLE
HR	COUNTRY_ID_NN	C	COUNTRIES	"COUNTRY_ID" IS NOT NULL				ENABLED	NOT DEFERRABLE
HR	REGION_ID_NN	C	REGIONS	"REGION_ID" IS NOT NULL				ENABLED	NOT DEFERRABLE
HR	JHIST_EMP_FK	R	JOB_HISTORY		HR	EMP_EMP_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE
HR	DEPT_MGR_FK	R	DEPARTMENTS		HR	EMP_EMP_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE
HR	EMP_MANAGER_FK	R	EMPLOYEES		HR	EMP_EMP_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE
HR	JHIST_JOB_FK	R	JOB_HISTORY		HR	JOB_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE
HR	EMP_JOB_FK	R	EMPLOYEES		HR	JOB_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE
HR	JHIST_DEPT_FK	R	JOB_HISTORY		HR	DEPT_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE
HR	EMP_DEPT_FK	R	EMPLOYEES		HR	DEPT_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE
HR	DEPT_LOC_FK	R	DEPARTMENTS		HR	LOC_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE
HR	LOC_C_ID_FK	R	LOCATIONS		HR	COUNTRY_C_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE
HR	COUNTR_REG_FK	R	COUNTRIES		HR	REG_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE
HR	COUNTRY_C_ID_PK	P	COUNTRIES					ENABLED	NOT DEFERRABLE
HR	DEPT_ID_PK	P	DEPARTMENTS					ENABLED	NOT DEFERRABLE
HR	EMP_EMAIL_UK	U	EMPLOYEES					ENABLED	NOT DEFERRABLE
HR	EMP_EMP_ID_PK	P	EMPLOYEES					ENABLED	NOT DEFERRABLE
HR	JHIST_EMP_ID_ST_DATE_PK	P	JOB_HISTORY					ENABLED	NOT DEFERRABLE
HR	JOB_ID_PK	P	JOBS					ENABLED	NOT DEFERRABLE
HR	LOC_ID_PK	P	LOCATIONS					ENABLED	NOT DEFERRABLE
HR	REG_ID_PK	P	REGIONS					ENABLED	NOT DEFERRABLE
HR	SYS_C007063	P	TBL_TEST1					ENABLED	NOT DEFERRABLE
*/

SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'TBL_TEST1';
--==>> HR	SYS_C007063	P	TBL_TEST1					ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	GENERATED NAME

--※ 제약조건이 지정된 컬럼을 확인(조회)
SELECT *
FROM USER_CONS_COLUMNS;
/*
HR	REGION_ID_NN	REGIONS	REGION_ID	
HR	REG_ID_PK	REGIONS	REGION_ID	1
HR	COUNTRY_ID_NN	COUNTRIES	COUNTRY_ID	
HR	COUNTRY_C_ID_PK	COUNTRIES	COUNTRY_ID	1
HR	COUNTR_REG_FK	COUNTRIES	REGION_ID	1
HR	LOC_ID_PK	LOCATIONS	LOCATION_ID	1
HR	LOC_CITY_NN	LOCATIONS	CITY	
HR	LOC_C_ID_FK	LOCATIONS	COUNTRY_ID	1
HR	DEPT_ID_PK	DEPARTMENTS	DEPARTMENT_ID	1
HR	DEPT_NAME_NN	DEPARTMENTS	DEPARTMENT_NAME	
HR	DEPT_MGR_FK	DEPARTMENTS	MANAGER_ID	1
HR	DEPT_LOC_FK	DEPARTMENTS	LOCATION_ID	1
HR	JOB_ID_PK	JOBS	JOB_ID	1
HR	JOB_TITLE_NN	JOBS	JOB_TITLE	
HR	EMP_EMP_ID_PK	EMPLOYEES	EMPLOYEE_ID	1
HR	EMP_LAST_NAME_NN	EMPLOYEES	LAST_NAME	
HR	EMP_EMAIL_NN	EMPLOYEES	EMAIL	
HR	EMP_EMAIL_UK	EMPLOYEES	EMAIL	1
HR	EMP_HIRE_DATE_NN	EMPLOYEES	HIRE_DATE	
HR	EMP_JOB_NN	EMPLOYEES	JOB_ID	
HR	EMP_JOB_FK	EMPLOYEES	JOB_ID	1
HR	EMP_SALARY_MIN	EMPLOYEES	SALARY	
HR	EMP_MANAGER_FK	EMPLOYEES	MANAGER_ID	1
HR	EMP_DEPT_FK	EMPLOYEES	DEPARTMENT_ID	1
HR	JHIST_EMPLOYEE_NN	JOB_HISTORY	EMPLOYEE_ID	
HR	JHIST_EMP_ID_ST_DATE_PK	JOB_HISTORY	EMPLOYEE_ID	1
HR	JHIST_EMP_FK	JOB_HISTORY	EMPLOYEE_ID	1
HR	JHIST_START_DATE_NN	JOB_HISTORY	START_DATE	
HR	JHIST_DATE_INTERVAL	JOB_HISTORY	START_DATE	
HR	JHIST_EMP_ID_ST_DATE_PK	JOB_HISTORY	START_DATE	2
HR	JHIST_END_DATE_NN	JOB_HISTORY	END_DATE	
HR	JHIST_DATE_INTERVAL	JOB_HISTORY	END_DATE	
HR	JHIST_JOB_NN	JOB_HISTORY	JOB_ID	
HR	JHIST_JOB_FK	JOB_HISTORY	JOB_ID	1
HR	JHIST_DEPT_FK	JOB_HISTORY	DEPARTMENT_ID	1
HR	SYS_C007063	TBL_TEST1	COL1	1
*/

SELECT *
FROM USER_CONS_COLUMNS
WHERE TABLE_NAME = 'TBL_TEST1';
--==>> HR	SYS_C007063	TBL_TEST1	COL1	1


--○ USER_CONSTRAINTS 와 USER_CONS_COLUMNS 를 대상으로
-- 제약조건이 설정된 소유주, 제약 조건명, 테이블명, 제약조건종류, 컬럼명 항목을 조회한다.
-- 내가한것
SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'TBL_TEST1';

SELECT *
FROM USER_CONS_COLUMNS
WHERE TABLE_NAME = 'TBL_TEST1';



SELECT *
FROM USER_CONSTRAINTS C1 , USER_CONS_COLUMS C2
WHERE C1.TABLE_NAME = C2.TABLE_NAME;



SELECT *
FROM USER_CONSTRAINTS C1 , USER_CONS_COLUMS C2
WHERE C1.TABLE_NAME = C2.TABLE_NAME;



SELECT *
FROM USER_CONSTRAINTS
WHERE CONSTRAINT_TYPE = 'P';



SELECT *
FROM USER_CONSTRAINTS C1 JOIN USER_CONS_COLUMS C2
ON C1.TABLE_NAME = C2.TABLE_NAME
AND CONSTRAINT_TYPE = 'P';



SELECT *
FROM USER_CONSTRAINTS C1 JOIN USER_CONS_COLUMS C2
ON CONSTRAINT_TYPE = 'P'
WHERE C1.TABLE_NAME = C2.TABLE_NAME;


------------------ T 선생님
SELECT UC.OWNER, UC.CONSTRAINT_NAME, UC.TABLE_NAME, UC.CONSTRAINT_TYPE
     , UCC.COLUMN_NAME
FROM USER_CONSTRAINTS UC ,USER_CONS_COLUMNS UCC
WHERE UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME;
 

SELECT UC.OWNER, UC.CONSTRAINT_NAME, UC.TABLE_NAME, UC.CONSTRAINT_TYPE
     , UCC.COLUMN_NAME
FROM USER_CONSTRAINTS UC ,USER_CONS_COLUMNS UCC
WHERE UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME
 AND UC.TABLE_NAME = 'TBL_TEST1';


--○ PK지정 실습(② 테이블 레벨의 형식)
CREATE TABLE TBL_TEST2
( COL1 NUMBER(5)
, COL2 VARCHAR2(30)
, CONSTRAINT TEST2_COL1_PK PRIMARY KEY(COL1)
);
--==>> Table TBL_TEST2이(가) 생성되었습니다.

--ㅁ 데이터 입력
INSERT INTO TBL_TEST2(COL1,COL2) VALUES (1,'TEST');
INSERT INTO TBL_TEST2(COL1,COL2) VALUES (1,'TEST');  --> 에러발생
INSERT INTO TBL_TEST2(COL1,COL2) VALUES (1,'ABCD');  --> 에러발생
INSERT INTO TBL_TEST2(COL1,COL2) VALUES (2,'ABCD');
INSERT INTO TBL_TEST2(COL1,COL2) VALUES (3,NULL);
INSERT INTO TBL_TEST2(COL1) VALUES (4);
INSERT INTO TBL_TEST2(COL1) VALUES (4);             --> 에러발생

INSERT INTO TBL_TEST2(COL1,COL2) VALUES (5,'ABCD');
INSERT INTO TBL_TEST2(COL1,COL2) VALUES (NULL,NULL); --> 에러발생
INSERT INTO TBL_TEST2(COL2) VALUES ('KKKK');         --> 에러발생


COMMIT;

SELECT *
FROM TBL_TEST2;
/*
1	TEST
2	ABCD
3	
4	
5	ABCD
*/

--○ USER_CONSTRAINTS 와 USER_CONS_COLUMNS 를 대상으로
-- 제약조건이 설정된 소유주, 제약 조건명, 테이블명, 제약조건종류, 컬럼명 항목을 조회한다.
SELECT UC.OWNER, UC.CONSTRAINT_NAME, UC.TABLE_NAME, UC.CONSTRAINT_TYPE
     , UCC.COLUMN_NAME
FROM USER_CONSTRAINTS UC ,USER_CONS_COLUMNS UCC
WHERE UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME
 AND UC.TABLE_NAME = 'TBL_TEST2';
--==>> HR	TEST2_COL1_PK	TBL_TEST2	P	COL1




--○ PK지정 실습(③다중 컬럼 PK 지정)
-- 테이블 생성
CREATE TABLE TBL_TEST3
( COL1 NUMBER(5)
, COL2 VARCHAR2(30)
, CONSTRAINT TEST3_COL1_COL2_PK PRIMARY KEY(COL1, COL2)
);
             --------------     ----------------------
               -- 이름            실제 제약조건이 걸리는 문법
--==>> Table TBL_TEST3이(가) 생성되었습니다.


-- 데이터 입력
INSERT INTO TBL_TEST3(COL1, COL2) VALUES(1, 'TEST');
INSERT INTO TBL_TEST3(COL1, COL2) VALUES(1, 'TEST');    --> 에러발생
INSERT INTO TBL_TEST3(COL1, COL2) VALUES(1, 'ABCD');                       -->★ 에러 안남 ★
INSERT INTO TBL_TEST3(COL1, COL2) VALUES(2, 'ABCD');
INSERT INTO TBL_TEST3(COL1, COL2) VALUES(2, 'TEST');
INSERT INTO TBL_TEST3(COL1, COL2) VALUES(3, NULL);      --> 에러발생
INSERT INTO TBL_TEST3(COL1, COL2) VALUES(NULL, 'TEST'); --> 에러발생
INSERT INTO TBL_TEST3(COL1, COL2) VALUES(NULL, NULL);   --> 에러발생


COMMIT;

SELECT *
FROM TBL_TEST3;


/*
1	ABCD
1	TEST
2	ABCD
2	TEST
3	NULL
*/


--○ USER_CONSTRAINTS 와 USER_CONS_COLUMNS 를 대상으로
-- 제약조건이 설정된 소유주, 제약조건명, 테이블명, 제약조건종류, 컬럼명 항목을 조회한다.
SELECT UC.OWNER, UC.CONSTRAINT_NAME, UC.TABLE_NAME, UC.CONSTRAINT_TYPE
     , UCC.COLUMN_NAME
FROM USER_CONSTRAINTS UC ,USER_CONS_COLUMNS UCC
WHERE UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME
 AND UC.TABLE_NAME = 'TBL_TEST3';
 
/*
HR	TEST3_COL1_COL2_PK	TBL_TEST3	P	COL1
HR	TEST3_COL1_COL2_PK	TBL_TEST3	P	COL2

제약조건의 이름이 같으면 제약조건은 하나다
*/


--○ PK 지정 실습(④ 테이블 생성 이후 제약조건 추가 설정)
-- 테이블생성

CREATE TABLE TBL_TEST4
( COL1 NUMBER(5)
, COL2 VARCHAR2(30)
);
--==>> Table TBL_TEST4이(가) 생성되었습니다.

--※ 이미 생성된(만들어져 있는)테이블에
--   부여하려는 제약조건을 위반한 데이터가 (단 하나라도)포함되어 있을 경우
--   해당 테이블에 제액조건을 추가하는 것은 불가능하다.

-- 제약조건 추가  -- 구조적인 변경
ALTER TABLE TBL_TEST4
ADD 컬럼명 데이터타입;

ALTER TABLE TBL_TEST4
ADD CONSTRAINT TEST4_COL1_PK PRIMARY KEY(COL1);
--==>> Table TBL_TEST4이(가) 변경되었습니다.

--○ USER_CONSTRAINTS 와 USER_CONS_COLUMNS 를 대상으로
-- 제약조건이 설정된 소유주, 제약조건명, 테이블명, 제약조건종류, 컬럼명 항목을 조회한다.
SELECT UC.OWNER, UC.CONSTRAINT_NAME, UC.TABLE_NAME, UC.CONSTRAINT_TYPE
     , UCC.COLUMN_NAME
FROM USER_CONSTRAINTS UC ,USER_CONS_COLUMNS UCC
WHERE UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME
 AND UC.TABLE_NAME = 'TBL_TEST4';
--==>> HR	TEST4_COL1_PK	TBL_TEST4	P	COL1


--※ 제약조건 확인 전용 뷰(VIEW) 생성
CREATE OR REPLACE VIEW VIEW_CONSTCHECK
AS
SELECT UC.OWNER"OWNER"
     , UC.CONSTRAINT_NAME "CONSTRAINT_NAME"
     , UC.TABLE_NAME"TABLE_NAME"
     , UC.CONSTRAINT_TYPE"CONSTRAINT_TYPE"
     , UCC.COLUMN_NAME "COLUMN_NAME"
     , UC.SEARCH_CONDITION"SEARCH_CONDITION"
     , UC.DELETE_RULE"DELETE_RULE" 
FROM USER_CONSTRAINTS UC JOIN USER_CONS_COLUMNS UCC
ON UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME;
--==>> View VIEW_CONSTCHECK이(가) 생성되었습니다.


--
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST4';
--==>> HR	TEST4_COL1_PK	TBL_TEST4	P	COL1		


--■■■ UNIQUE ■■■--

--1. 테이블에서 지정한 컬럼의 데이터가 중복되지 않고 유일 할 수 있도록 설정하는 제약조건
--   PRIMARY KEY 와 유사한 제약조건이지만, ★NULL을 허용한다는 차이점이 있다.
--   내부적으로 PRIMARY KEY 와 마찬가지로 UNIQUE INDEX 가 자동생성된다.
--   하나의 테이블 내에서 ★ UNIQUE 제약조건은 여러 번 설정하는 것이 가능하다.
--   즉,  하나의 테이블에 UNIQUE 제약조건의 컬럼을 여러 개 만드는 것은 가능하는 것이다.
-- 고유하기만 하면된다.

--2. 형식 및 구조
-- ① 컬럼 레벨의 형식
-- 컬럼명 데이터 타입[CONSTRAUNT CONSTRAINT명] UNIQUE

-- ② 테이블 레벨의 형식
-- 컬럼명 데이터 타입,
-- 컬럼명 데이터타입,
-- CONSTRAINT CONSTRAINT명 UNIQUE(컬럼명,....)

--○ UK 지정 실습( ① 컬럼 레벨의 형식)
-- 테이블 생성
CREATE TABLE TBL_TEST5
( COL1 NUMBER(5)        PRIMARY KEY
, COL2 VARCHAR2(30)     UNIQUE
);
--==>> Table TBL_TEST5이(가) 생성되었습니다.

-- 제약조건 조회
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST5';
/*
HR	SYS_C007067	TBL_TEST5	P	COL1		
HR	SYS_C007068	TBL_TEST5	U	COL2		
*/



-- 데이터 입력
INSERT INTO TBL_TEST5(COL1,COL2) VALUES(1,'TEST');
INSERT INTO TBL_TEST5(COL1,COL2) VALUES(1,'TEST');          --> 에러 발생
INSERT INTO TBL_TEST5(COL1,COL2) VALUES(2,'ABCD');
INSERT INTO TBL_TEST5(COL1,COL2) VALUES(3,'ABCD');          --> 에러 발생
INSERT INTO TBL_TEST5(COL1,COL2) VALUES(3,NULL);   
-- NULL 은 데이터가 아니다
INSERT INTO TBL_TEST5(COL1) VALUES(4);  
INSERT INTO TBL_TEST5(COL1,COL2) VALUES(5,'ABCD');          --> 에러 발생

-- 확인
SELECT *
FROM TBL_TEST5;
/*
1	TEST
2	ABCD
3	(null)
4	(null)
*/




--○ UK 지정 실습(② 테이블 레벨의 형식)
-- 테이블 생성
CREATE TABLE TBL_TEST6
( COL1 NUMBER(5)
, COL2 VARCHAR2(30)
, CONSTRAINT TEST6_COL1_PK PRIMARY KEY(COL1)
, CONSTRAINT TEST6_COL2_UK UNIQUE(COL2)
);
--==>> Table TBL_TEST6이(가) 생성되었습니다.

SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST6';
/*
HR	TEST6_COL1_PK	TBL_TEST6	P	COL1		
HR	TEST6_COL2_UK	TBL_TEST6	U	COL2			
*/


--○ UK 지정 실습(③ 테이블 생성 이후 제약조건 추가)

--테이블 생성

CREATE TABLE TBL_TEST7
( COL1  NUMBER(5)
, COL2  VARCHAR2(30)
);
--==>> Table TBL_TEST7이(가) 생성되었습니다.

-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME ='TBL_TEST7';
--==>> 조회 결과 없음

-- 제약조건 추가
ALTER TABLE TBL_TEST7
ADD CONSTRAINT TEST7_COL1_PK PRIMARY KEY(COL1);
--  +
ALTER TABLE TBL_TEST7
ADD CONSTRAINT TEST7_COL2_UK UNIQUE(COL2);
----↓

ALTER TABLE TBL_TEST7
ADD(CONSTRAINT TEST7_COL1_PK PRIMARY KEY(COL1)
  , CONSTRAINT TEST7_COL2_UK UNIQUE(COL2));
--==>>Table TBL_TEST7이(가) 변경되었습니다.


-- 제약조건 추가 이후 다시 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST7';
/*
HR	TEST7_COL1_PK	TBL_TEST7	P	COL1		
HR	TEST7_COL2_UK	TBL_TEST7	U	COL2		
*/




--------------------------------------------------------------------------------

-- ■■■ CHECK(CK:C) ■■■--


--1. 컬럼에서 허용 가능한 데이터의 범위나 조건을 지정하기 위한 제약조건
             -------------------------------
--          데이터타입과 길이로 1차 필터링 가능 하지만
-- NUMBER(3) = -999 ~ 999  

--   컬럼에 입력되는 데이터를 검사하여 조건에 맞는 데이터만 입력될 수 있도록 한다.
--   또한, 컬럼에서 수정되는 데이터를 검사하여 조건에 맞는 데이터로 수정되는 것만
--   허용하는 기능을 수행하게 된다.
 
--2. 형식 및 구조
-- ① 컬럼 레벨의 형식
-- 컬럼명 데이터타입[CONSTRAINT CONSTRAINT명] CHECK(컬럼명 조건)

-- ② 테이블 레벨의 형식
-- 컬럼명 데이터타입,
-- 컬럼명 데이터타입,
-- CONSTRAINT CONSTRAINT명 CHECK(컬럼 조건)


--○ CK 지정 실습(① 컬럼 레벨의 형식)

CREATE TABLE TBL_TEST8
( COL1 NUMBER(5)        PRIMARY KEY
, COL2 VARCHAR2(30)    
, COL3 NUMBER(3)        CHECK (COL3 BETWEEN 0 AND 100)
);
--==>> Table TBL_TEST8이(가) 생성되었습니다.

--데이터 입력

INSERT INTO TBL_TEST8(COL1, COL2, COL3) VALUES(1, '조영관', 100);
INSERT INTO TBL_TEST8(COL1, COL2, COL3) VALUES(1, '민찬우', 100);  --> 에러 발생
INSERT INTO TBL_TEST8(COL1, COL2, COL3) VALUES(2, '민찬우', 101);  --> 에러 발생
INSERT INTO TBL_TEST8(COL1, COL2, COL3) VALUES(2, '민찬우', -1);   --> 에러 발생
INSERT INTO TBL_TEST8(COL1, COL2, COL3) VALUES(2, '민찬우', 80);


-- 확인
SELECT *
FROM TBL_TEST8;
/*
1	조영관	100
2	민찬우	80
*/

-- 커밋
COMMIT;
--==>> 커밋 완료.

-- 제약 조건확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST8';
/*
HR	SYS_C007073	TBL_TEST8	C	COL3	    COL3 BETWEEN 0 AND 100	
HR	SYS_C007074	TBL_TEST8	P	COL1		(null)
*/

--○  CK 지정 실습 (② 테이블 레벨의 형식)
-- 테이블 생성
CREATE TABLE TBL_TEST9
( COL1 NUMBER(5)
, COL2 VARCHAR2(30)
, COL3 NUMBER(3)
, CONSTRAINT TEST9_COL1_PK PRIMARY KEY(COL1)
, CONSTRAINT TEST9_COL3_CK CHECK(COL3 BETWEEN 0 AND 100)
);
--==>> Table TBL_TEST9이(가) 생성되었습니다.
--==> 다시해야함 ........

INSERT INTO TBL_TEST9(COL1, COL2, COL3) VALUES(1, '조영관', 100);
INSERT INTO TBL_TEST9(COL1, COL2, COL3) VALUES(1, '민찬우', 100);  --> 에러 발생
INSERT INTO TBL_TEST9(COL1, COL2, COL3) VALUES(2, '민찬우', 101);  --> 에러 발생
INSERT INTO TBL_TEST9(COL1, COL2, COL3) VALUES(2, '민찬우', -1);   --> 에러 발생
INSERT INTO TBL_TEST9(COL1, COL2, COL3) VALUES(2, '민찬우', 80);



-- 제약 조건확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST9';


--○ CK 지정 실습(③ 테이블 생성 이후 제약조건 추가)

CREATE TABLE TBL_TEST10
( COL1 NUMBER(5)
, COL2 VARCHAR2(30)
, COL3 NUMBER(3)
);
--==>> Table TBL_TEST10이(가) 생성되었습니다.

-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST10';
--==>> 조회 결과 없음

-- 제약조건 추가
ALTER TABLE TBL_TEST10
ADD( CONSTRAINT TEST10_COL1_PK PRIMARY KEY(COL1)
   , CONSTRAINT TEST10_COL3_CK CHECK (COL3 BETWEEN 0 AND 100));
--==>> Table TBL_TEST10이(가) 변경되었습니다.

-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST10';
/*
HR	TEST10_COL1_PK	TBL_TEST10	P	COL1		
HR	TEST10_COL3_CK	TBL_TEST10	C	COL3	    COL3 BETWEEN 0 AND 100	
*/


-- 테이블 생성
CREATE TABLE TBL_TESTMEMBER
( SID NUMBER
, NAME VARCHAR2(30)
, SSN CHAR(14)          -- 입력형태 → 'YYMMDD-NNNNNNN'
, TEL VARCHAR2(40)
);
--==>> Table TBL_TESTMEMBER이(가) 생성되었습니다.

--○ TBL_TESTMEMBER 테이블의 SSN 컬럼(주민등록번호 컬럼) 에서
-- 데이터 입력이나 수정시 성별이 유효한 데이터만 입력 될 수 있도록
-- 체크 제약조건을 추가 할 수 있도록 한다.
-- (→  주민등록 특정자리에 입력 가능한 데이터를 1,2,3,4, 만 가능하도록 처리)
-- 또한, SID 컬럼에는 PRIMARY KEY 제약조건을 설정할 수 있도록한다. DO


SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TESTMEMBER';


-- 내가 한 것 틀림.......
ALTER TABLE TBL_TESTMEMBER
ADD( CONSTRAINT TESTMEMBER_SID_PK PRIMARY KEY(SID)
   , CONSTRAINT TESTMEMBER_SSN_CK CHECK (SSN BETWEEN '_______1______' AND '_______4______'));
--==>> Table TBL_TESTMEMBER이(가) 변경되었습니다.


-- 친구가 한 것
ALTER TABLE TBL_TESTMEMBER
ADD( CONSTRAINT TESTMEMBER_SID_PK PRIMARY KEY(SID)
   , CONSTRAINT TESTMEMBER_SSN_CK CHECK(TO_NUMBER(SUBSTR(SSN,8,1)BETWEEN 1 AND 4)) );



ALTER TABLE TBL_TESTMEMBER
DROP CHECK;


-- DROP 방법
ALTER TABLE TBL_TESTMEMBER
DROP CONSTRAINT TESTMEMBER_SSN_CK;

ROLLBACK;

DESC TBL_TESTMEMBER;

-- 제약 조건 추가
ALTER TABLE TBL_TESTMEMBER
ADD( CONSTRAINT TESTMEMBER_SID_PK PRIMARY KEY(SID)
    , CONSTRAINT TESTMEMBER_SSD_CK CHECK(주민번호 8번째자리 1개가 '1' 또는 '2' 또는 '3' 또는'4'));

ALTER TABLE TBL_TESTMEMBER
ADD( CONSTRAINT TESTMEMBER_SID_PK PRIMARY KEY(SID)
    , CONSTRAINT TESTMEMBER_SSD_CK CHECK(SUBSTR(SSN 8,1)가 '1' 또는 '2' 또는 '3' 또는'4'));

ALTER TABLE TBL_TESTMEMBER
ADD( CONSTRAINT TESTMEMBER_SID_PK PRIMARY KEY(SID)
    , CONSTRAINT TESTMEMBER_SSD_CK CHECK(SUBSTR(SSN 8,1) IN ('1','2','3','4')) );
--==>> 
ALTER TABLE TBL_TESTMEMBER
ADD( CONSTRAINT TESTMEMBER_SSD_CK CHECK(SUBSTR(SSN, 8,1) IN ('1','2','3','4')) );





-- 
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TESTMEMBER';



-- 데이터
INSERT INTO TBL_TESTMEMBER(SID, NAME, SSN, TEL)
VALUES(1, '엄소연', '941124-2234567','010-1111-1111');
INSERT INTO TBL_TESTMEMBER(SID, NAME,SSN,TEL)
VALUES(2, '최동현', '950222-1234567','010-2222-2222');
INSERT INTO TBL_TESTMEMBER(SID, NAME,SSN,TEL)
VALUES(3, '유동현', '040601-3234567','010-3333-3333');
INSERT INTO TBL_TESTMEMBER(SID, NAME,SSN,TEL)
VALUES(4, '김유림', '050215-4234567','010-3333-3333');

INSERT INTO TBL_TESTMEMBER(SID, NAME,SSN,TEL)           
VALUES(5, '김유림', '050215-5234567','010-5555-5555');     --> 에러 발생
INSERT INTO TBL_TESTMEMBER(SID, NAME,SSN,TEL)
VALUES(6, '김유림', '050215-6234567','010-6666-6666');     --> 에러 발생


SELECT *
FROM TBL_TESTMEMBER;
/*
엄소연	941124-2234567	010-1111-1111
최동현	950222-1234567	010-2222-2222
유동현	040601-3234567	010-3333-3333
김유림	050215-4234567	010-3333-3333
*/

COMMIT;
--==>> 커밋 완료.


--------------------------------------------------------------------------------

--■■■ FOREIGN KEY(FK:F:R) ■■■--

--1. 참조 키(R) 또는 외래 키(FK:F)는 두 테이블의 데이터 간 연결을 설정하고
--   강제 적용시키는데 사용되는 열이다.
--   한 테이블의 기본 키 값이 있는 열을
--   다음 테이블에 추가하면 테이블 간 연결을 설정 할 수 있다.
--   이 때, 두 번째 테이블에 추가되는 열이 외래키가 된다.


--2. ① 부모 테이블(참조받는 컬럼이 포함된 테이블)이 먼저 생성된 후
--   ② 자식 테이블(참조하는 컬럼이 포함된 테이블)이 생성되어야 한다.
--   이 때, 자식 테이블에 FOREIGN KEY 제약조건이 설정된다.

--3. 형식 및 구조
-- ① 컬럼 레벨의 형식
-- 컬럼명 데이터타입 [CONSTRAINT CONSTRAINT명]
--                  REFERENCES 참조테이블명(참조컬럼명)
--                  [ON DELETE CASCADE | ON DELETE SET NULL] → 추가옵션(있을수도 없을수도있음)


-- ② 테이블 레벨의 형식
-- 컬럼명 데이터타입,
-- 컬럼명 데이터타입,
--CONSTRAINT CONSTRAINT명 FOREIGN KEY(컬럼명)
--           REFERENCES 참조테이블명(참조컬럼명)
--           [ON DELETE CASCADE | ON DELETE SET NULL] → 추가옵션


-- ※ FOREIGN KEY 제약조건을 설정하는 실습을 진행하기 위해서는
--   부모 테이블의 생성 작업을 먼저 수행해야한다.
--   그리고 이때, 부모 테이블에서는 반드시 PK 또는 UK 제약조건이
--   설정된 컬럼이 존재해야한다.


/*
★ 꼭 기억해두기 ★
-- 길이를 지정하지 않으면
컬럼명 CHAR        -- 한 글자
컬럼명 NUMBER      -- 표현범위를 다 갖는것 10의 38승(모든 숫자가 가능)
*/


-- 부모 테이블 생성
CREATE TABLE TBL_JOBS
( JIKWI_ID      NUMBER
, JIKWI_NAME    VARCHAR2(30)
, CONSTRAINT JOBS_ID_PK PRIMARY KEY(JIKWI_ID)
);
--==>> Table TBL_JOBS이(가) 생성되었습니다.

-- 부모 테이블에 데이터 입력
INSERT INTO TBL_JOBS(JIKWI_ID, JIKWI_NAME) VALUES(1,'사원');
INSERT INTO TBL_JOBS(JIKWI_ID, JIKWI_NAME) VALUES(2,'대리');
INSERT INTO TBL_JOBS(JIKWI_ID, JIKWI_NAME) VALUES(3,'과장');
INSERT INTO TBL_JOBS(JIKWI_ID, JIKWI_NAME) VALUES(4,'부장');
--==>> 1 행 이(가) 삽입되었습니다. * 4


-- 확인
SELECT *
FROM TBL_JOBS;
/*
1	사원
2	대리
3	과장
4	부장
*/


-- 의도한 대로 잘 들어갔으면 커밋
COMMIT;
--==>> 커밋 완료.


--○ FK 지정 실습 (① 컬럼 레벨의 형식)
-- 테이블 생성
CREATE TABLE TBL_EMP1
( SID       NUMBER      PRIMARY KEY
, NAME      VARCHAR2(30)
, JIKWI_ID  NUMBER      REFERENCES TBL_JOBS(JIKWI_ID)
);
--==>> Table TBL_EMP1이(가) 생성되었습니다.


-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_EMP1';

/*
HR	SYS_C007082	TBL_EMP1    	P	SID		
HR	SYS_C007083	TBL_EMP1	    R	JIKWI_ID		NO ACTION
                                           추가옵션유무
*/

-- 데이터 입력
INSERT INTO TBL_EMP1(SID, NAME, JIKWI_ID) VALUES(1,'정미경', 1);
INSERT INTO TBL_EMP1(SID, NAME, JIKWI_ID) VALUES(2,'최나윤', 2);
INSERT INTO TBL_EMP1(SID, NAME, JIKWI_ID) VALUES(3,'민찬우', 3);
INSERT INTO TBL_EMP1(SID, NAME, JIKWI_ID) VALUES(4,'조영관', 4);

INSERT INTO TBL_EMP1(SID, NAME, JIKWI_ID) VALUES(5,'고연수', 5);   --> 에러 발생
INSERT INTO TBL_EMP1(SID, NAME, JIKWI_ID) VALUES(5,'고연수', 1);
INSERT INTO TBL_EMP1(SID, NAME) VALUES(6,'김태민');


-- 확인
SELECT *
FROM TBL_EMP1;
/*
1	정미경	1
2	최나윤	2
3	민찬우	3
4	조영관	4
5	고연수	1
6	김태민	(null)
*/

COMMIT;
--==>> 커밋 완료.



--○ FK 지정 실습(② 테이블 레벨의 형식)
CREATE TABLE TBL_EMP2
( SID       NUMBER
, NAME      VARCHAR2(30)
, JIKWI_ID  NUMBER
, CONSTRAINT EMP2_SID_PK PRIMARY KEY(SID)
, CONSTRAINT EMP2_JIKWI_ID_FK FOREIGN KEY(JIKWI_ID)
             REFERENCES TBL_JOBS(JIKWI_ID)
);


--○ FK 지정 실습(② 테이블 생성후 제약조건 추가)
CREATE TABLE TBL_EMP3
( SID   NUMBER
, NAME  VARCHAR2(30)
, JIKWI_ID  NUMBER
);
--==>> Table TBL_EMP3이(가) 생성되었습니다.


-- 제약조건추가
ALTER TABLE TBL_EMP3
ADD( CONSTRAINT EMP3_SID_PK  PRIMARY KEY(SID)
   , CONSTRAINT EMP3_JIKWI_ID_FK FOREIGN KEY(JIKWI_ID)
             REFERENCES TBL_JOBS(JIKWI_ID) );
--==>> Table TBL_EMP3이(가) 변경되었습니다.


-- 제약조건 제거
ALTER TABLE TBL_EMP3
DROP CONSTRAINT EMP3_JIKWI_ID_FK;
--==>> Table TBL_EMP3이(가) 변경되었습니다.

-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_EMP3';
--==>> HR	EMP3_SID_PK	TBL_EMP3	P	SID		


-- 다시 제약조건 추가

ALTER TABLE TBL_EMP3
ADD CONSTRAINT EMP3_JIKWI_ID_FK FOREIGN KEY(JIKWI_ID)
               REFERENCES TBL_JOBS(JIKWI_ID);
--==>> Table TBL_EMP3이(가) 변경되었습니다.               
                
-- 다시 제약조건확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_EMP3';

/*
HR	EMP3_SID_PK	    TBL_EMP3	P	SID		
HR	EMP3_JIKWI_ID_FK	TBL_EMP3	R	JIKWI_ID		NO ACTION
*/

-- 4. FOREIGN KEY 생성 시 주의사항
--      참조하고자하는 부모 테이블을 먼저 생성해야한다.
--      참조하고자 하는 컬럼이 PRIMARY KEY 또는 UNIQUE 제약조건이 설정되어 있어야한다.
--      테이블 사이에 PRIMARY KEY 와 FOREIGN KEY 가 정의되어 있으면
--      PRIMARY KEY 제약조건이 설정된 데이터 삭제 시
--      FOREIGN KEY 컬럼에 그 값이 입력되어 있는 경우 삭제되지 않는다.
--      (즉, 자식테이블에 참조하는 레코드가 존재할 경우
--      부모 테이블의 참조받는 해당 레코드는 삭제 할 수 었다는 것이다.)
--      단, FK 설정 과정에서 『ON DELETE CASCADE』『ON DELETE SET NULL』옵션을
--      사용하여 설정한 경우에는 삭제가 가능하다.
--      또한, 부모 테이블을 제거하기 위해서는 자식 테이블을 먼저 제거해야한다.


-- 부모테이블
SELECT *
FROM TBL_JOBS;
/*
1	사원
2	대리
3	과장
4	부장
*/
-- 자식 테이블
SELECT *
FROM TBL_EMP1;
/*
1	정미경	1
2	최나윤	2
3	민찬우	3
4	조영관	4
5	고연수	1
6	김태민	(null)      
*/

-- 부모 테이블 제거 시도
DROP TABLE TBL_JOBS;
--==>> 에러 발생

-- 부모 테이블의 부장 직원 삭제 시도
SELECT *
FROM TBL_JOBS
WHERE JIKWI_ID = 4;
--==>> 4	부장

DELETE
FROM TBL_JOBS
WHERE JIKWI_ID = 4;
--==>> 에러 발생


-- 조영관 부장의 직위를 사원으로 변경
UPDATE TBL_EMP1
SET JIKWI_ID = 1
WHERE SID  = 4;
--==>> 1 행 이(가) 업데이트되었습니다.



-- 확인
SELECT *
FROM TBL_EMP1;
/*
1	정미경	1
2	최나윤	2
3	민찬우	3
4	조영관	1
5	고연수	1
6	김태민	(null)
*/

-- 커밋
COMMIT;
--==>> 커밋 완료.

-- 부모 테이블(TBL_JOBS)의 부장(4) 데이터를 참조하고 있는 
-- 자식 테이블(TBL_EMP1)의 데이터가 존재하지 않는 상황

-- 이와 같은 상황에서 부모테이블(TBL_JOBS)DML
-- 부장 데이터 삭제
DELETE
FROM TBL_JOBS
WHERE JIKWI_ID = 4;
--==>> 1 행 이(가) 삭제되었습니다.

-- 확인
SELECT *
FROM TBL_JOBS;
/*
1	사원
2	대리
3	과장
*/

-- 커밋
COMMIT;
--==>> 커밋 완료.

-- 부모 테이블(TBL_JOBS)의 사원 데이터 삭제
SELECT *
FROM TBL_JOBS
WHERE JIKWI_ID = 1;
--==>> 1	사원


DELETE
FROM TBL_JOBS
WHERE JIKWI_ID = 1;
--==>> 에러 발생


-- ※ 부모 테이블의 데이터를 자유롭게(?) 삭제하기 위해서는
-- ON DELETE CASCADE 옵션 지정이 필요하다.

-- TBL_EMP1 테이블(자식 테이블) 에서 FK 제약조건을 제거한 후
-- CASECADE 옵션을 포함하여 다시 FK 제약조건을 설정한다.



-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_EMP1';    
/*
HR	SYS_C007082	TBL_EMP1	P	SID		
HR	SYS_C007083	TBL_EMP1	R	JIKWI_ID		NO ACTION  ◀◀◀
*/



-- 제약 조건제거
ALTER TABLE TBL_EMP1
DROP CONSTRAINT SYS_C007083;        -- ◀◀◀ FK FOREIGN KEY, 참조키, 외래키만 제거 
--==>> Table TBL_EMP1이(가) 변경되었습니다.




-- 제약조건 제거 이후 다시 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_EMP1'; 
--==>> HR	SYS_C007082	TBL_EMP1	P	SID		




--『ON DELETE CASCADE』옵션이 포함된 내용으로 제약조건 다시 지정
ALTER TABLE TBL_EMP1
ADD CONSTRAINT EMP1_JIKWI_ID_FK FOREIGN KEY(JIKWI_ID)
                REFERENCES TBL_JOBS(JIKWI_ID)
                ON DELETE CASCADE; 
--==>> Table TBL_EMP1이(가) 변경되었습니다.

-- 제약조건 생성이후 다시 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_EMP1';  
/*
HR	SYS_C007082	    TBL_EMP1	P	SID		
HR	EMP1_JIKWI_ID_FK	TBL_EMP1	R	JIKWI_ID		CASCADE
*/

-- ※ CASECADE 옵션을 지정한 후에는
--   참조받고 있는 부모 테이블의 데이터를
--   언제든지 자유롭게 삭제하는 것이 가능하다.
--   단, ....부모 테이블의 데이터가 삭제될 경우...
--   이를 참조하는 자식 테이블의 데이터도 모~~~~두 함께 삭제된다.



-- 부모테이블
SELECT *
FROM TBL_JOBS;
/*
1	사원
2	대리
3	과장
*/
-- 자식 테이블
SELECT *
FROM TBL_EMP1;
/*
1	정미경	1
2	최나윤	2
3	민찬우	3
4	조영관	1
5	고연수	1
6	김태민	(null)    
*/

-- 부모 테이블(TBL_JOBS)에서 과장 데이터 삭제
DELETE
FROM TBL_JOBS
WHERE JIKWI_ID = 3;
--==>> 1 행 이(가) 삭제되었습니다.


SELECT *
FROM TBL_EMP1;
/*
1	정미경	1
2	최나윤	2
4	조영관	1
5	고연수	1
6	김태민	(null)    
*/




-- 부모 테이블(TBL_JOBS)에서 사원(1) 데이터 삭제
DELETE
FROM TBL_JOBS
WHERE JIKWI_ID = 1;
--==>> 1 행 이(가) 삭제되었습니다.




-- 자식 테이블
SELECT *
FROM TBL_EMP1;
/*
2	최나윤	2
6	김태민	(null)
*/
--==>> 사원(1)에 속하는 자식데이터 다 사라짐




DROP TABLE TBL_EMP2;
--==>> Table TBL_EMP2이(가) 삭제되었습니다.
-- 생성 시에는 부모 → 자식 생성
-- 삭제 시에는 자식 → 부모 삭제 즉, 반대로

DROP TABLE TBL_EMP3;
--==>> Table TBL_EMP3이(가) 삭제되었습니다.

DROP TABLE TBL_JOBS;
--==>> 에러 발생

DROP TABLE TBL_EMP1;
--==>> Table TBL_EMP1이(가) 삭제되었습니다.


DROP TABLE TBL_JOBS;
--==>> Table TBL_JOBS이(가) 삭제되었습니다.

